!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
DEV_NAME	krwx.h	/^#define DEV_NAME /;"	d
INCLUDE_VERMAGIC	krwx.mod.c	/^#define INCLUDE_VERMAGIC$/;"	d	file:
IOCTL_KFREE	krwx.h	/^#define IOCTL_KFREE /;"	d
IOCTL_KMALLOC	krwx.h	/^#define IOCTL_KMALLOC /;"	d
IOCTL_MEMK_ALLOC	krwx.h	/^#define IOCTL_MEMK_ALLOC /;"	d
IOCTL_MEMK_CREATE	krwx.h	/^#define IOCTL_MEMK_CREATE /;"	d
IOCTL_MEMK_FREE	krwx.h	/^#define IOCTL_MEMK_FREE /;"	d
IOCTL_RW_READ	krwx.h	/^#define IOCTL_RW_READ /;"	d
IOCTL_RW_WRITE	krwx.h	/^#define IOCTL_RW_WRITE /;"	d
IOCTL_TEST_KMEM	krwx.h	/^#define IOCTL_TEST_KMEM /;"	d
K	Makefile	/^K=\/home\/parallels\/hacking\/kernel\/working_krwx\/linux-5.10.152\/$/;"	m
MAX_KMEM	krwx.h	/^#define MAX_KMEM /;"	d
_GFP_KERN	hooking.c	/^#define _GFP_KERN /;"	d	file:
_GFP_KERN	krwx.h	/^#define _GFP_KERN /;"	d
_GFP_USER	hooking.c	/^#define _GFP_USER /;"	d	file:
_GFP_USER	krwx.h	/^#define _GFP_USER /;"	d
_HOOKED_FUNC_H	hooking.c	/^#define _HOOKED_FUNC_H$/;"	d	file:
align	krwx.h	/^    size_t align;$/;"	m	struct:io_kmem_create
cc_copy_from_user	hooking.c	/^unsigned long cc_copy_from_user(void* to, const void* __user *from, unsigned long n){ $/;"	f
cc_copy_to_user	hooking.c	/^unsigned long cc_copy_to_user(void* __user to, const void* from, unsigned long n){ $/;"	f
cc_kfree	hooking.c	/^void cc_kfree(const void* objp){$/;"	f
cc_kmalloc	hooking.c	/^void * cc_kmalloc(size_t size, gfp_t flags){$/;"	f
content	krwx.h	/^    uint64_t* content; \/\/ Init 0 from client-side$/;"	m	struct:msg_read
flags	krwx.h	/^    gfp_t flags;$/;"	m	struct:io_kmalloc
flags	krwx.h	/^    gfp_t flags;$/;"	m	struct:io_kmem_alloc
flags	krwx.h	/^    unsigned long flags;$/;"	m	struct:io_kmem_create
gfp_t	krwx.h	/^typedef unsigned int gfp_t;$/;"	t
global_kmem	krwx.c	/^struct kmem_cache* global_kmem[MAX_KMEM];$/;"	v	typeref:struct:kmem_cache
index	krwx.h	/^    int index;$/;"	m	struct:io_kmem_create
index	krwx.h	/^    unsigned int index;$/;"	m	struct:io_kmem_alloc
index	krwx.h	/^    unsigned int index;$/;"	m	struct:io_kmem_free
io_kmalloc	krwx.h	/^struct io_kmalloc {$/;"	s
io_kmem_alloc	krwx.h	/^struct io_kmem_alloc{$/;"	s
io_kmem_create	krwx.h	/^struct io_kmem_create {$/;"	s
io_kmem_free	krwx.h	/^struct io_kmem_free{$/;"	s
ioctl_kfree	lib/rw.c	/^int ioctl_kfree(void* arg){$/;"	f
ioctl_kmalloc	lib/rw.c	/^int ioctl_kmalloc(struct io_kmalloc* __user arg){$/;"	f
ioctl_kmem_alloc	lib/rw.c	/^int ioctl_kmem_alloc(struct io_kmem_alloc* __user user_kmem){$/;"	f
ioctl_kmem_create_usercopy	lib/rw.c	/^int ioctl_kmem_create_usercopy(struct io_kmem_create* __user user_kmem){$/;"	f
ioctl_kmem_free	lib/rw.c	/^int ioctl_kmem_free(struct io_kmem_free* __user user_kmem){$/;"	f
ioctl_kmem_test	lib/rw.c	/^int ioctl_kmem_test(unsigned long arg){$/;"	f
ioctl_rw_read	lib/rw.c	/^int ioctl_rw_read(struct msg_read* read_msg){$/;"	f
ioctl_rw_write	lib/rw.c	/^unsigned long ioctl_rw_write(struct msg_write* write_msg){$/;"	f
kaddress	krwx.h	/^    void* kaddress;$/;"	m	struct:msg_read
kaddress	krwx.h	/^    void* kaddress;$/;"	m	struct:msg_write
krwx_exit	krwx.c	/^module_exit(krwx_exit);$/;"	v
krwx_exit	krwx.c	/^void krwx_exit(void){$/;"	f
krwx_fops	krwx.c	/^static const struct file_operations krwx_fops = {$/;"	v	typeref:struct:file_operations	file:
krwx_init	krwx.c	/^int krwx_init(void){$/;"	f
krwx_init	krwx.c	/^module_init(krwx_init);$/;"	v
krwx_ioctl	krwx.c	/^long int krwx_ioctl(struct file *fp, unsigned int cmd, unsigned long arg){$/;"	f
krwx_miscdev	krwx.c	/^static struct miscdevice krwx_miscdev = {$/;"	v	typeref:struct:miscdevice	file:
krwx_open	krwx.c	/^int krwx_open(struct inode *inode, struct file *file){$/;"	f
krwx_read	krwx.c	/^ssize_t krwx_read(struct file * file, char __user *buf, size_t count, loff_t *pos){$/;"	f
krwx_release	krwx.c	/^int krwx_release(struct inode *inode, struct file *file){$/;"	f
krwx_write	krwx.c	/^ssize_t krwx_write(struct file * file, const char __user *buf, size_t count, loff_t *pos){$/;"	f
msg_read	krwx.h	/^struct msg_read{$/;"	s
msg_write	krwx.h	/^struct msg_write{$/;"	s
name	krwx.h	/^    char* name;$/;"	m	struct:io_kmem_create
obj_size	krwx.h	/^    size_t obj_size;$/;"	m	struct:io_kmem_create
pointer	krwx.h	/^    void* pointer;$/;"	m	struct:io_kmem_free
result	krwx.h	/^    void* result; \/\/ userland kmalloc return address$/;"	m	struct:io_kmalloc
result	krwx.h	/^    void* result;$/;"	m	struct:io_kmem_alloc
size	krwx.h	/^    size_t size;$/;"	m	struct:io_kmalloc
size	krwx.h	/^    uint64_t size;$/;"	m	struct:msg_read
size	krwx.h	/^    uint64_t size;$/;"	m	struct:msg_write
useroffset	krwx.h	/^    size_t useroffset;$/;"	m	struct:io_kmem_create
usersize	krwx.h	/^    size_t usersize;$/;"	m	struct:io_kmem_create
value	krwx.h	/^    uint64_t* value;$/;"	m	struct:msg_write
